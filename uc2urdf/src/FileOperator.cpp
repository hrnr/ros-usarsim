/*****************************************************************************
 DISCLAIMER:
 This software was produced by the National Institute of Standards
 and Technology (NIST), an agency of the U.S. government, and by statute is
 not subject to copyright in the United States.  Recipients of this software
 assume all responsibility associated with its operation, modification,
 maintenance, and subsequent redistribution.

 See NIST Administration Manual 4.09.07 b and Appendix I.
 *****************************************************************************/
#include "FileOperator.h"
#include "ArmLink.h"
#include "ArmJoint.h"
#include "URDF.h"
#include "Config.h"
#include "XMLWriter.h"
#include <stdexcept>
#include <iostream>
#include <sstream>
#include <fstream>      // std::ifstream, std::ofstream


/*!
 *\brief Auto-generated constructor stub,
 */
FileOperator::FileOperator()
{
}

/*!
 *\brief Auto-generated destructor stub.
 */
FileOperator::~FileOperator()
{
}

/*!
 *\brief Fill out the vector member \a m_armlink with instances of the class ArmLink.
 *
 *\param _armlink An instance of the class ArmLink to push in the vector \a m_armlink.
 */
void FileOperator::addArmLinkToList(ArmLink *_armlink)
{
    m_armlink.push_back(_armlink);
}

/*!
 *\brief Add an object of ArmLink in \a the vector m_armlink at position \a _position.
 *
 *\param _armlink An object of the class ArmLink to push in the vector \a m_armlink.
 *\param _position The position at which to include the object \a armlink
 */
void FileOperator::addArmLinkAtPosition(ArmLink *_armlink, int _position)
{
    m_armlink.insert(m_armlink.begin()+_position, _armlink);
}

/*!
 *\brief Add an object of ArmJoint in \a the vector m_armjoint at position \a _position
 *
 *\param _armjoint An object of the class ArmJoint to push in the vector \a m_armjoint.
 *\param _position The position at which to include the object \a armlink
 */
void FileOperator::addArmJointAtPosition(ArmJoint *_armjoint, int _position)
{
    m_armjoint.insert(m_armjoint.begin()+_position, _armjoint);
}

/*!
 \brief Add the link <i>base_link</i> as the first link in FileOperator::m_armlink.

 <i>base_link</i> is generated by ROS tf and does not appear in the .uc file. It is necessay that we force its addition in FileOperator::m_armlink.
 */
void FileOperator::addLink_base_link()
{
    ArmLink* base_link = new ArmLink();
    base_link->setLinkName("base_link");
    addArmLinkAtPosition(base_link, 0);
}

/*!
 \brief Add the joint <i>KR60Arm_mount</i> as the first link in FileOperator::m_armjoint.

 \verbatim
 <joint name="KR60Arm_mount" type="fixed">
 <parent link="base_link" />
 <child link="KR60Arm_link0" />
 <origin xyz="0.00 0.00 -0.00" rpy="0.00 -0.00 0.00" />
 </joint>
 \endverbatim
 <i>KR60Arm_mount</i> is generated by ROS tf and does not appear in the .uc file. It is necessay that we force its addition in FileOperator::m_armjoint.
 */
void FileOperator::addJoint_mount()
{
    ArmJoint* mount_joint = new ArmJoint();
    mount_joint->setJointName("KR60Arm_mount");
    mount_joint->setJointParent("base_link");
    mount_joint->setJointChild("KR60Arm_link0");
    mount_joint->setJointOffsetVector(0.00,0.00,-0.00);
    mount_joint->setJointRPYVector(0.00,-0.00,0.00);
    addArmJointAtPosition(mount_joint,0);
}

/*!
 \brief Insert a string within a string at position 1
 \param s The entry string
 \param replacement The string to include in the original string
 */
void FileOperator::changeDotNegativeDecimal (std::string &_string, std::string _replacement)
{
    _string.insert(1,_replacement);
}

/*!
 \brief Insert a string within a string at position 0
 \param s The entry string
 \param replacement The string to include in the original string
 */
void FileOperator::changeDotPositiveDecimal (std::string &_string, std::string _replacement)
{
    _string = _replacement + _string;
}

/*!
 \brief Find a whole word within a string.

 If the user looks for the word "rain" in the sentence "the rain in the drain", the word rain is found only once even though "rain"
 is found in the word "drain".

 \param sentence The string where the word is searched
 \param word The word to look within a string
 \return true if the word is found within the string, false otherwise
 */
bool FileOperator::contains_word(const std::string& _sentence, const std::string& _word)
{
    size_t pos = -1;
    // Find the start of 'word' in 'sentence'.
    while ((pos = _sentence.find(_word, pos + 1)) != std::string::npos)
    {
        // Make sure it's actually a word (e.g. "rain" could be part of
        // "drain"). isalpha checks if the given character is in the
        // alphabet. Here we check if the characters before and after
        // 'word' are alphabet characters. If neither of them is an
        // alphabet character then we've found a whole word.
        bool start = ((pos < 1) || !(isalpha(_sentence[pos - 1])));
        bool end = ((pos + _word.size() > _sentence.size() || !(isalpha(_sentence[pos + _word.size()]))));
        if (start && end)
            return true;
    }
    // If we get to here then we didn't find any instance of 'word' that was
    // a whole word.
    return false;
}

/*!
 *\brief Read \a FileOperator::m_joint_angle and display the values in the shell.
 */
void FileOperator::displayJointAngles()
{
    std::vector<Vector3d> v_joint_angles = getJointAngle();
    std::string sep = "\n----------------------------------------\n";
    cout<<sep;
    cout << "\t      Joint Angle " << sep;

    for (vector<Vector3d>::size_type j=0; j<v_joint_angles.size(); j++)
        cout<< v_joint_angles[j] << sep;
}

/*!
 *\brief Read \a FileOperator::m_joint_position and display the values in the shell.
 */
void FileOperator::displayJointPosition()
{
    std::vector<Vector3d> v_list_position = getJointPosition();
    std::string sep = "\n----------------------------------------\n";
    cout<<sep;
    cout << "\t     Joint Position " << sep;

    for (vector<Vector3d>::size_type j=0; j<v_list_position.size(); j++)
        cout<< v_list_position[j] << sep;
}

/*!
 *\brief Read \a FileOperator::m_link_position and display the values in the shell.
 */
void FileOperator::displayLinkPosition()
{
    std::vector<Vector3d> v_list_position = getLinkPosition();
    std::string sep = "\n----------------------------------------\n";
    cout<<sep;
    cout << "\t      Link Position " << sep;

    for (vector<Vector3d>::size_type j=0; j<v_list_position.size(); j++)
        cout<< v_list_position[j] << sep;

}

/*!
 \brief Read \a FileOperator::m_armjoint and display on the screen stored joint data from a .uc file.
 */
void FileOperator::displayUCJoint()
{
    std::vector<ArmJoint*> myVector = getArmJoint();
    int myVector_size = (int)myVector.size();

    for (vector<ArmJoint*>::size_type i = 0; i < myVector_size; i++)
    {
        cout <<"\njoint: " << myVector[i]->getJointName()<< endl;
        cout <<"parent: " << myVector[i]->getJointParent()<< endl;
        cout <<"child: " << myVector[i]->getJointChild()<< endl;
        cout <<"damping: " << myVector[i]->getJointDamping()<< endl;
        if(myVector[i]->getJointMaxForce())
            cout <<"maxforce: " << myVector[i]->getJointMaxForce()<< endl;

        cout <<"limitlow: " << myVector[i]->getJointLimitLow()<< endl;

        cout <<"limithigh: " << myVector[i]->getJointLimitHigh()<< endl;

        std::vector<double> v_tmpOffset = myVector[i]->getJointOffsetVector();
        for (vector<double>::size_type j = 0; j < v_tmpOffset.size(); j++)
            cout << v_tmpOffset[j]<< " ";

        cout << "\n";
        std::vector<double> v_tmpRPY = myVector[i]->getJointRPYVector();
        for (vector<double>::size_type k = 0; k < v_tmpRPY.size(); k++)
            cout << v_tmpRPY[k]<< " ";

        cout << "\n\n";
    }
}


/*!
 \brief Reads \a FileOperator::m_armlink and display on the screen stored link data from a .uc file.
 */
void FileOperator::displayUCLink()
{
    std::vector<ArmLink*> myVector = getArmLink();
    int myVector_size = (int)myVector.size();

    for (vector<ArmLink*>::size_type i = 0; i < myVector_size; i++)
    {
        cout << myVector[i]->getLinkName()<< " --> ";

        std::vector<double> v_tmpOffset = myVector[i]->getOffsetVector();
        if (v_tmpOffset.size()>0)
            for (vector<double>::size_type j = 0; j < v_tmpOffset.size(); j++)
                cout << v_tmpOffset[j]<< " ";

        cout << " --> ";
        cout << myVector[i]->getColladaPath()<< "\n\n";
        //cout << "\n\n";
    }
}

/**
 \brief Read \a m_urdfjoint_list and display all the attributes that have been stored.
 */
void FileOperator::displayUrdfJoint()
{
    std::vector<URDF*> tmp_urdfjoint = getUrdfJointList();

    std::string sep = "\n------------------------------------------------------------\n";
    cout<<sep;
    cout << "\t      Joints from Original URDF " << sep;
    for (vector<URDF*>::size_type i = 0; i < tmp_urdfjoint.size(); i++)
    {
        cout <<"\njoint name: " << tmp_urdfjoint[i]->getJoint_name()<< endl;
        cout <<"joint type: " << tmp_urdfjoint[i]->getJoint_type()<< endl;
        cout <<"parent link: " << tmp_urdfjoint[i]->getJointParent_link()<< endl;
        cout <<"child link: " << tmp_urdfjoint[i]->getJointChild_link()<< endl;
        cout <<"origin xyz: " << tmp_urdfjoint[i]->getJointOrigin_xyz()<< endl;
        cout <<"origin rpy: " << tmp_urdfjoint[i]->getJointOrigin_rpy()<< endl;
        if (!tmp_urdfjoint[i]->getJointAxis_xyz().empty())
            cout << "axis xyz: "  << tmp_urdfjoint[i]->getJointAxis_xyz() << endl;
        if (!tmp_urdfjoint[i]->getJointLimit_effort().empty())
            cout << "limit effort: "  << tmp_urdfjoint[i]->getJointLimit_effort() << endl;
        if (!tmp_urdfjoint[i]->getJointLimit_upper().empty())
            cout << "limit upper: "  << tmp_urdfjoint[i]->getJointLimit_upper() << endl;
        if (!tmp_urdfjoint[i]->getJointLimit_lower().empty())
            cout << "limit lower: "  << tmp_urdfjoint[i]->getJointLimit_lower() << endl;
        if (!tmp_urdfjoint[i]->getJointLimit_velocity().empty())
            cout << "limit velocity: "  << tmp_urdfjoint[i]->getJointLimit_velocity() << endl;
    }
}


/**
 \brief Read \a m_urdflink_list and display on the screen all the attributes that have been stored.
 */
void FileOperator::displayUrdfLink()
{
    std::vector<URDF*> tmp_urdflink = getUrdfLinkList();
    std::string sep = "\n-----------------------------------------------------\n";
    cout<<sep;
    cout << "\t      Links from Original URDF " << sep;
    for (vector<URDF*>::size_type i = 0; i < tmp_urdflink.size(); i++)
    {
        std::string link_name=tmp_urdflink[i]->getLink_name();

        cout <<"\nlink name: " << link_name << endl;

        if (!tmp_urdflink[i]->getLinkBox_size().empty())
            cout << "box size: "  << tmp_urdflink[i]->getLinkBox_size() << endl;
        if (!tmp_urdflink[i]->getLinkOrigin_xyz().empty())
            cout << "origin xyz: "  <<  tmp_urdflink[i]->getLinkOrigin_xyz() << endl;
        if (!tmp_urdflink[i]->getLinkOrigin_rpy().empty())
            cout << "origin rpy: "  <<  tmp_urdflink[i]->getLinkOrigin_rpy() << endl;
    }

}

/*!
 *\brief Retrieve the vector \a m_armjoint.
 *
 *\return The vector \a m_armjoint.
 */
std::vector<ArmJoint*> FileOperator::getArmJoint()
{
    return m_armjoint;
}

/*!
 \brief Retrieve the vector member \a m_armlink.

 \return The vector \a m_armlink.
 */
std::vector<ArmLink*> FileOperator::getArmLink()
{
    return m_armlink;
}

/*!
 \brief open and read CONFIG_INI to retrieve data from each section.

 <ul>
 <li>The [COLLADA] section consists of paths to collada files for each link.
 <li>The [LINK] section matches .uc link names with urdf link names.
 <li>The [JOINT] section matches .uc joint names with urdf joint names.
 </ul>

 \param _section The section in which we are interested.

 */
void FileOperator::getIniData(std::string _section)
{
    std::vector<ArmLink*> v_armlink = getArmLink();
    int v_armlink_size = (int)v_armlink.size();
    std::vector<ArmJoint*> v_armjoint = getArmJoint();
    int v_armjoint_size = (int)v_armjoint.size();
    std::string section;
    //--Read CONFIG_INI to retrieve the collada model for each link
    string f_collada = CONFIG_INI;
    ifstream inifile;
    inifile.open(f_collada.c_str());
    bool b_section = false;

    if (inifile.is_open())
    {
        std::string line;

        //-- Ignore everything after comments in config.ini file (after //)
        int indexComment = line.find("//");
        if (indexComment>=0)
            line = line.substr (0,indexComment);

        while (getline(inifile, line))
        {
            //-- Make sure we are not reading empty lines or we would get segmentation fault
            if (!line.empty())
            {
                //-- Retrieve the position of the opening and closing brackets
                int indexOpeningBracket = line.find("[");
                int indexClosingBracket = line.find("]");

                //-- If closing and opening brackets exist
                //-- get the name of the section inside these brackets
                if (indexOpeningBracket>=0 && indexClosingBracket>=0)
                {
                    section = line.substr(indexOpeningBracket+1,indexClosingBracket-(indexOpeningBracket+1));
                    //cout << "Section: " << section << endl;
                    if (section.compare(_section) == 0)
                        b_section = true;
                    else
                        b_section = false;
                }
                //--If we are in the right section
                if (b_section)
                {
                    //-- store each word of a line into a vector
                    std::vector<std::string> v_string = splitString(line);
                    //-- If we are into the [COLLADA] section
                    if (section.compare("COLLADA") == 0)
                    {
                        for (vector<ArmLink*>::size_type i = 0; i < v_armlink_size; i++)
                        {
                            //-- Check if the first element of the vector is the same
                            if (v_string[0].compare(v_armlink[i]->getLinkName()) == 0)
                            {
                                //cout << "Link: " << v_armlink[i]->getLinkName() << "\t Collada Path: " << v_string[1] << endl;
                                //-- Set the collada path for this link
                                v_armlink[i]->setColladaPath(v_string[1]);
                            }
                        }
                    }
                    //-- If we are into the [LINK] section
                    else if(section.compare("LINK") == 0)
                    {
                        //-- For each link in v_armlink, change the name
                        for (vector<ArmLink*>::size_type i = 0; i < v_armlink_size; i++)
                        {
                            //-- Check if the first element of the vector is the same as the name of the link
                            if (v_string[0].compare(v_armlink[i]->getLinkName()) == 0)
                            {
                                //-- Change the name of the link to the name given in the config.ini file
                                v_armlink[i]->setLinkName(v_string[1]);
                            }
                        }
                        //-- For each joint in v_armjoint, change the name of the parent and child
                        for (vector<ArmJoint*>::size_type j = 0; j < v_armjoint_size; j++)
                        {
                            //-- Check if the name of the parent link for the joint j matches any name in config.ini
                            if (v_string[0].compare(v_armjoint[j]->getJointParent()) == 0)
                            {
                                //-- Change the name of the parent to the name given in config.ini
                                v_armjoint[j]->setJointParent(v_string[1]);
                            }
                            //-- Check if the name of the child link for the joint j matches any name in config.ini
                            if (v_string[0].compare(v_armjoint[j]->getJointChild()) == 0)
                            {
                                //-- Change the name of the child to the name given in config.ini
                                v_armjoint[j]->setJointChild(v_string[1]);
                            }
                        }
                    }
                    else if(section.compare("JOINT") == 0)
                    {

                        for (vector<ArmJoint*>::size_type k = 0; k < v_armjoint_size; k++)
                        {
                            //-- Check if the first element of the vector is the same as the name of the joint
                            if (v_string[0].compare(v_armjoint[k]->getJointName()) == 0)
                            {
                                //-- Change the name of the joint to the name given in the config.ini file
                                v_armjoint[k]->setJointName(v_string[1]);
                            }
                        }
                    }
                    else if(section.compare("LINK_ORIENTATION") == 0)
                    {
                        for (vector<ArmLink*>::size_type i = 0; i < v_armlink_size; i++)
                        {
                            //-- Check if the first element of the vector is the same as the name of the link
                            if (v_string[0].compare(v_armlink[i]->getLinkName()) == 0)
                            {
                                //-- Set the rpy of the link using the one stored in config.ini
                                v_armlink[i]->setRPYVector(atof(v_string[1].c_str()),atof(v_string[2].c_str()),atof(v_string[3].c_str()));
                            }
                        }
                    }

                }
            }
        }
    }
}

/*!
 *\brief Get the vector FileOperator::m_joint_angle that consists of orientations of all joints.
 *
 *\return The vector of joint orientations.
 */
std::vector<Vector3d> FileOperator::getJointAngle()
{
    return m_joint_angle;
}

/*!
 *\brief Get the vector FileOperator::m_joint_position that consists of joint positions.
 *
 *\return The vector of joint positions.
 */
std::vector<Vector3d> FileOperator::getJointPosition()
{
    return m_joint_position;
}

/*!
 *\brief Get the vector FileOperator::m_link_position that consists of link positions.
 *
 *\return The vector of link positions.
 */
std::vector<Vector3d> FileOperator::getLinkPosition()
{
    return m_link_position;
}

/*!
 \brief Retrieve the vector member \a m_urdfjoint_list.

 \return The vector \a m_urdfjoint_list.
 */
std::vector<URDF*> FileOperator::getUrdfJointList()
{
    return m_input_urdfjoint_list;
}

/*!
 \brief Retrieve the vector member \a m_urdflink_list.

 \return The vector \a m_urdflink_list.
 */
std::vector<URDF*> FileOperator::getUrdfLinkList()
{
    return m_input_urdflink_list;
}

/*!
 \brief Check if the first character of a string is a dot "." (e.g., .34)
 \param s The entry string
 \return True if the string starts with ".", false otherwise
 */
bool FileOperator::isDotPositiveDecimal(std::string _string)
{
    char c = _string[0];
    std::string first_letter;
    stringstream ss;
    ss << c;
    ss >> first_letter;

    if (first_letter.compare(".") == 0)
        return true;
    else
        return false;
}

/*!
 \brief Check if the first character of a string is "-" and the second character is "." (e.g., -.34)

 \param s The entry string
 \return True if the string starts with "-.", false otherwise
 */
bool FileOperator::isDotNegativeDecimal(std::string _string)
{
    char c1 = _string[0];
    char c2 = _string[1];
    std::string first_letter, second_letter;
    stringstream ss1, ss2;
    ss1 << c1;
    ss1 >> first_letter;
    ss2 << c2;
    ss2 >> second_letter;

    if (first_letter.compare("-") == 0)
        if (second_letter.compare(".") == 0)
            return true;
    return false;
}

/*!
 *\brief Read and display elements of a std::vector<std::string>.
 *
 *\param _vector The vector<string> to read
 */
void FileOperator::readVector(vector<std::string> _vector)
{
    int vectLength;
    vectLength=(int)_vector.size();

    for (vector<int>::size_type i = 0; i < vectLength; i++)
        cout <<_vector[i]<< " ";
    cout<< endl;
}

/*!
 *\brief Read and display elements of a std::vector<double>.
 *
 *\param _vector The vector<double> to read.
 */
void FileOperator::readVector(vector<double> _vector)
{
    int vectLength;
    vectLength=(int)_vector.size();

    for (vector<int>::size_type i = 0; i < vectLength; i++)
        cout <<_vector[i]<< " ";
    cout<< endl;
}

/*!
 \brief Read the elements of a map that contains a vector as the second parameter
 \param myMap The map to read
 */

void FileOperator::readMapOfVector(std::map<std::string,std::vector<std::string> > _map)
{
    for(std::map<std::string, std::vector<std::string> >::iterator iter = _map.begin(); iter != _map.end(); ++iter )
    {
        cout  << iter->first << " ";
        for (std::vector<std::string> ::size_type i = 0; i < iter->second.size(); i++)
            cout << iter->second[i] << " ";
        cout  << endl;
    }
}


/*!
 \brief Read the elements of a map.
 \param _map The map to read
 */
void FileOperator::readMapOfVector(std::map<string,std::vector<double> > _map)
{
    for(map<string, vector<double> >::iterator iter = _map.begin(); iter != _map.end(); ++iter )
    {
        cout  << iter->first << " ";
        for (vector<double> ::size_type i = 0; i < iter->second.size(); i++)
            cout << iter->second[i] << " ";
        cout  << endl;
    }
}

/*!
 \brief Read the elements of a map
 \param myMap The map to read
 */
void FileOperator::readMap(map<string,string> _map)
{
    for(std::map<std::string,std::string>::iterator iter = _map.begin(); iter != _map.end(); ++iter )
    {
        cout  << iter->first << " ";
        cout  << iter->second << endl;
    }
}

/*!
 *\brief Open and read a .uc file.
 *
 *This function consists of two functions:
 *<ul>
 *   <li>FileOperator::readUCLink(std::string) stores link data.
 *   <li>FileOperator::readUCJoint(std::string) stores joint data.
 *</ul>
 *
 *\param _filename Name of the .uc file to read.
 */
void FileOperator::readUcFile(string _filename)
{
    readUCLink(_filename);
    readUCJoint(_filename);
}

/*!
 \brief Read a .uc file and gather information on arm joints.

 \param _filename Name of the .uc file to read.
 */
void FileOperator::readUCJoint(string _filename)
{
    double d_xvalue, d_yvalue, d_zvalue;
    double d_roll_value, d_pitch_value, d_yaw_value;

    ifstream inputfile;
    inputfile.open(_filename.c_str());

    //-- Bunch of strings that will need to be found in the .uc file
    std::string s_joint ("Class=RevoluteJoint");
    std::string s_jointname ("Name=");
    std::string s_parent ("Parent=");
    std::string s_child ("Child=");
    std::string s_damping ("Damping=");
    std::string s_maxforce ("MaxForce=");
    std::string s_limitlow ("LimitLow=");
    std::string s_limithigh ("LimitHigh=");
    std::string s_offset ("Offset=");
    std::string s_rpy ("Direction=");
    std::string s_X ("X=");
    std::string s_Y ("Y=");
    std::string s_Z ("Z=");
    std::string s_Roll ("x=");
    std::string s_Pitch ("y=");
    std::string s_Yaw ("z=");
    std::string s_comment ("//");
    std::string s_comma (",");
    std::string s_closingParenthesis (")");

    bool b_armjoint = false;
    int armjoint_count = 0;
    //-- Let's get to work
    if (inputfile.is_open())
    {
        std::string line;
        //-- Walk through inputfile once to look for s_joint
        while (getline(inputfile, line))
        {
            //-- Ignore everything after comments in the .uc file (after //)
            int indexComment = line.find(s_comment);
            if (indexComment>=0)
                line = line.substr (0,indexComment);

            //-- Remove blank spaces in each line
            //-- Just in case the .uc file has "Class = RevoluteJoint" instead of "Class=RevoluteJoint"
            std::string newline = stripSpace(line);

            //---------------------------------------------------------//
            //-- Look for the string "Class=RevoluteJoint" in each line
            //---------------------------------------------------------//
            int indexJoint = newline.find(s_joint);
            if (indexJoint>=0)
            {
                b_armjoint = true;
                //+++++++++++++++++++++++++++++++//
                //-- Look for the string "Name="
                //+++++++++++++++++++++++++++++++//
                int indexJointName = newline.find(s_jointname);
                if (indexJointName>=0)
                {
                    armjoint_count++;
                    int strlength = s_jointname.length();
                    //cout << "\n\nName: " << newline.substr(indexJointName+strlength) << endl;
                    ArmJoint *armjoint = new ArmJoint();
                    armjoint->setJointName(newline.substr(indexJointName+strlength));
                    setArmJoint(armjoint);
                }
            }


            //---------------------------------------------------------//
            //-- Look for the string "Parent=" in each line
            //---------------------------------------------------------//
            int indexParent = newline.find(s_parent);
            if (indexParent >= 0)
            {
                int strlength = s_parent.length();

                //-- Get the ArmJoint object from the m_armjoint vector at position armjoint_count-1
                //-- Update this object with information on the "Parent"
                getArmJoint().at(armjoint_count-1)->setJointParent(newline.substr(indexParent+strlength));
                //cout << "Parent: " << newline.substr(indexParent+strlength) << endl;
                //cout << "count: "<<armjoint_count<<endl;
            }

            //---------------------------------------------------------//
            //-- Look for the string "Child=" in each line
            //---------------------------------------------------------//
            int indexChild = newline.find(s_child);
            if (indexChild >= 0)
            {
                int strlength = s_child.length();
                //-- Get the ArmJoint object from the m_armjoint vector at position armjoint_count-1
                //-- Update this object with information on the "Child"
                getArmJoint().at(armjoint_count-1)->setJointChild(newline.substr(indexChild+strlength));
                //cout << "Child: " << newline.substr(indexChild+strlength) << endl;
            }

            //---------------------------------------------------------//
            //-- Look for the string "Damping=" in each line
            //---------------------------------------------------------//
            int indexDamping = newline.find(s_damping);
            if (indexDamping >= 0)
            {
                int strlength = s_damping.length();
                std::string s_damping_value = newline.substr(indexDamping+strlength);
                double d_damping = atof(s_damping_value.c_str());
                //-- Get the ArmJoint object from the m_armjoint vector at position armjoint_count-1
                //-- Update this object with information on the "Child"
                getArmJoint().at(armjoint_count-1)->setJointDamping(d_damping);
                //cout << "Damping: " << s_damping_value << endl;
            }

            //---------------------------------------------------------//
            //-- Look for the string "MaxForce=" in each line
            //---------------------------------------------------------//
            int indexMaxForce = newline.find(s_maxforce);
            if (indexMaxForce >= 0)
            {
                int strlength = s_maxforce.length();
                std::string s_maxforce_value = newline.substr(indexMaxForce+strlength);
                //cout << "MaxForce: " << newline.substr(indexMaxForce+strlength) << endl;
                double d_maxforce = atof(s_maxforce_value.c_str());
                getArmJoint().at(armjoint_count-1)->setJointMaxForce(d_maxforce);
            }

            //---------------------------------------------------------//
            //-- Look for the string "LimitLow=" in each line
            //---------------------------------------------------------//
            int indexLimitLow = newline.find(s_limitlow);
            if (indexLimitLow >= 0)
            {
                int strlength = s_limitlow.length();
                std::string s_limitlow_value = newline.substr(indexLimitLow+strlength);
                //cout << "LimitLow: " << newline.substr(indexLimitLow+strlength) << endl;
                double d_limitlow = atof(s_limitlow_value.c_str());
                getArmJoint().at(armjoint_count-1)->setJointLimitLow(d_limitlow);

            }

            //---------------------------------------------------------//
            //-- Look for the string "LimitHigh=" in each line
            //---------------------------------------------------------//
            int indexLimitHigh = newline.find(s_limithigh);
            if (indexLimitHigh >= 0)
            {
                int strlength = s_limithigh.length();
                std::string s_limithigh_value = newline.substr(indexLimitHigh+strlength);
                //cout << "LimitHigh: " << newline.substr(indexLimitHigh+strlength) << endl;
                double d_limithigh = atof(s_limithigh_value.c_str());
                getArmJoint().at(armjoint_count-1)->setJointLimitHigh(d_limithigh);
            }


            //---------------------------------------------//
            //-- Look for the string "Direction=" in each line
            //---------------------------------------------//
            int indexRPY = newline.find(s_rpy);
            if (indexRPY>=0)
            {
                //-- We are looking for specifically the word "Offset" and not words like "TipOffset"
                if (contains_word(newline,s_rpy))
                {
                    //-- Look for the string "x="
                    int index_Roll = newline.find(s_Roll);
                    //-- Look for the string "y="
                    int index_Pitch = newline.find(s_Pitch);
                    //-- Look for the string "z="
                    int index_Yaw = newline.find(s_Yaw);
                    //-- Look for commas that separate x, y, and z
                    int index_comma = newline.find(s_comma);
                    //-- Look for the closing parenthesis on this line
                    int indexClosingParenthesis = newline.find(s_closingParenthesis);

                    //-- Count the number of commas in each line
                    int comma_count = 0;
                    for(std::string::size_type pos=0; pos<line.size(); pos+=s_comma.size())
                    {
                        //-- Find the position of commas in the string
                        //-- There are 2 commas in "Offset=(X= .512,Y= .252, Z = -1.384)"
                        pos=newline.find(s_comma, pos);
                        if(pos==std::string::npos)
                            break;
                        comma_count++;

                        //-- We get the value for Roll
                        if (comma_count==1)
                        {
                            int strlength = s_Roll.length();
                            std::string s_roll_value = newline.substr(index_Roll+strlength,pos-(index_Roll+strlength));

                            //-- If the first character of s_xvalue is a "."
                            //-- Add "0" in the front
                            if (isDotPositiveDecimal(s_roll_value))
                                changeDotPositiveDecimal (s_roll_value,"0");

                            if (isDotNegativeDecimal(s_roll_value))
                                changeDotNegativeDecimal (s_roll_value,"0");

                            //std::cout <<"s_roll_value: "<< s_roll_value << endl;
                            d_roll_value = atof(s_roll_value.c_str());
                        }
                        //-- We get the value for Pitch
                        else if (comma_count==2)
                        {
                            int strlength = s_Pitch.length();
                            std::string s_pitch_value = newline.substr(index_Pitch+strlength,pos-(index_Pitch+strlength));

                            if (isDotPositiveDecimal(s_pitch_value))
                                changeDotPositiveDecimal (s_pitch_value,"0");

                            if (isDotNegativeDecimal(s_pitch_value))
                                changeDotNegativeDecimal (s_pitch_value,"0");

                            //std::cout <<"s_pitch_value: "<< s_pitch_value << endl;
                            d_pitch_value = atof(s_pitch_value.c_str());
                        }
                        
                    }
                    comma_count = 0;

                    //-- Look for the position of the closing parenthesis
                    //-- This used to find the Yaw value
                    if (indexClosingParenthesis>=0)
                    {
                        int strlength = s_Yaw.length();
                        std::string s_yaw_value = newline.substr(index_Yaw+strlength,indexClosingParenthesis-(index_Yaw+strlength));

                        if (isDotPositiveDecimal(s_yaw_value))
                            changeDotPositiveDecimal (s_yaw_value,"0");

                        if (isDotNegativeDecimal(s_yaw_value))
                            changeDotNegativeDecimal (s_yaw_value,"0");

                        //std::cout <<"s_yaw_value: "<< s_yaw_value << endl;
                        d_yaw_value = atof(s_yaw_value.c_str());
                    }
                    //cout << "Joint RPY: "<<d_roll_value<<","<<d_pitch_value<<","<<d_yaw_value<<endl;
                    getArmJoint().at(armjoint_count-1)->setJointRPYVector(d_roll_value, d_pitch_value, d_yaw_value);
                }
            }

            
            
            //---------------------------------------------//
            //-- Look for the string "Offset" in each line
            //---------------------------------------------//
            int indexOffset = line.find(s_offset);
            //-- Gather Offset information only for "Class=RevoluteJoint"
            if (b_armjoint)
            {
                if (indexOffset>=0)
                {
                    //-- We are looking for specifically the word "Offset" and not words like "TipOffset"
                    if (contains_word(line,s_offset))
                    {
                        //-- Look for the string "X="
                        int index_X = newline.find(s_X);
                        //-- Look for the string "Y="
                        int index_Y = newline.find(s_Y);
                        //-- Look for the string "Z="
                        int index_Z = newline.find(s_Z);
                        //-- Look for commas that separate X, Y, and Z
                        int index_comma = newline.find(s_comma);
                        //-- Look for the closing parenthesis on this line
                        int indexClosingParenthesis = newline.find(s_closingParenthesis);

                        //-- Count the number of commas in each line
                        int comma_count = 0;

                        for(std::string::size_type pos=0; pos<line.size(); pos+=s_comma.size())
                        {
                            //-- Find the position of commas in the string
                            //-- There are 2 commas in "Offset=(X= .512,Y= .252, Z = -1.384)"
                            pos=newline.find(s_comma, pos);
                            if(pos==std::string::npos)
                                break;
                            comma_count++;

                            //-- We get the value for X
                            if (comma_count==1)
                            {
                                int strlength = s_X.length();
                                std::string s_xvalue = newline.substr(index_X+strlength,pos-(index_X+strlength));

                                //-- If the first character of s_xvalue is a "."
                                //-- Add "0" in the front
                                if (isDotPositiveDecimal(s_xvalue))
                                    changeDotPositiveDecimal (s_xvalue,"0");

                                if (isDotNegativeDecimal(s_xvalue))
                                    changeDotNegativeDecimal (s_xvalue,"0");

                                //std::cout <<"s_xvalue: "<< s_xvalue << endl;
                                d_xvalue = atof(s_xvalue.c_str());
                            }
                            //-- We get the value for Y
                            else if (comma_count==2)
                            {
                                int strlength = s_Y.length();
                                std::string s_yvalue = newline.substr(index_Y+strlength,pos-(index_Y+strlength));

                                if (isDotPositiveDecimal(s_yvalue))
                                    changeDotPositiveDecimal (s_yvalue,"0");

                                if (isDotNegativeDecimal(s_yvalue))
                                    changeDotNegativeDecimal (s_yvalue,"0");

                                //std::cout <<"s_yvalue: "<< s_yvalue << endl;
                                d_yvalue = atof(s_yvalue.c_str());
                            }
                        }
                        comma_count = 0;

                        //-- Look for the position of the closing parenthesis
                        //-- This used to find the Z value
                        if (indexClosingParenthesis>=0)
                        {
                            int strlength = s_Z.length();
                            std::string s_zvalue = newline.substr(index_Z+strlength,indexClosingParenthesis-(index_Z+strlength));

                            if (isDotPositiveDecimal(s_zvalue))
                                changeDotPositiveDecimal (s_zvalue,"0");

                            if (isDotNegativeDecimal(s_zvalue))
                                changeDotNegativeDecimal (s_zvalue,"0");

                            //std::cout <<"s_zvalue: "<< s_zvalue << endl;
                            d_zvalue = atof(s_zvalue.c_str());
                        }
                        //cout << "Joint Offset: "<<d_xvalue<<","<<d_yvalue<<","<<d_zvalue<<endl;
                        getArmJoint().at(armjoint_count-1)->setJointOffsetVector(d_xvalue,d_yvalue,d_zvalue);
                    }
                }
            }
        }
    }
    inputfile.close();
}


/*!
 \brief Read a .uc file a gather information on arm links.

 \param _filename Name of the .uc file to read
 */
void FileOperator::readUCLink(string _filename)
{
    ArmLink *armlink = new ArmLink();
    double d_xvalue, d_yvalue, d_zvalue;
    ifstream inputfile;
    inputfile.open(_filename.c_str());

    //-- get the line with Class=Part
    std::string s_part ("Class=Part");
    std::string s_offset ("Offset");
    std::string s_partName ("Name=");
    std::string s_X ("X=");
    std::string s_Y ("Y=");
    std::string s_Z ("Z=");
    std::string s_comma (",");
    std::string s_comment ("//");
    std::string s_closingParenthesis (")");
    std::string partName;

    int s_part_count = 0;
    int new_part_count = 0;

    if (inputfile.is_open())
    {
        std::string tmpline;
        //-- Walk through inputfile once to count the number of time "Class=Part" appears
        while (getline(inputfile, tmpline))
        {
            //-- Ignore everything after comments in the .uc file (after //)
            int indexComment = tmpline.find(s_comment);
            if (indexComment>=0)
                tmpline = tmpline.substr (0,indexComment);


            //-- Remove blank spaces in each line.
            std::string tmpnewline = stripSpace(tmpline);

            //------------------------------------------------//
            //-- Look for the string "Class=Part" in each line
            //------------------------------------------------//
            int indexPart = tmpnewline.find(s_part);
            //-- checkpoint #1
            if (indexPart>=0)
            {
                //-- Look for the string "Name=" in each line
                int indexPartName = tmpnewline.find(s_partName);
                if (indexPartName >= 0)
                    s_part_count++;
            }

        }
        // cout << "number of links: "<<s_part_count<<"\n\n";
    }

    inputfile.close();
    inputfile.open(_filename.c_str());

    if (inputfile.is_open())
    {
        std::string line;

        //-- Walk through inputfile once to look for s_part
        while (getline(inputfile, line))
        {
            if (new_part_count < s_part_count-1)
            {
                //-- Ignore everything after comments in the .uc file (after //)
                int indexComment = line.find(s_comment);
                if (indexComment>=0)
                    line = line.substr (0,indexComment);


                //-- Remove blank spaces in each line.
                std::string newline = stripSpace(line);

                //------------------------------------------------//
                //-- Look for the string "Class=Part" in each line
                //------------------------------------------------//
                int indexPart = newline.find(s_part);
                //-- checkpoint #1
                if (indexPart>=0)
                {
                    //-- Look for the string "Name=" in each line
                    int indexPartName = newline.find(s_partName);
                    if (indexPartName >= 0)
                    {
                        int strlength = s_partName.length();
                        partName = newline.substr(indexPartName+strlength);
                        //cout << "LINK: "<<partName<<endl;
                        armlink->setLinkName(partName);
                        armlink->setOffsetVector(0.0,0.0,0.0);
                        armlink->setOffsetMap();
                    }
                }

                //---------------------------------------------//
                //-- Look for the string "Offset" in each line
                //---------------------------------------------//
                int indexOffset = line.find(s_offset);
                if (indexOffset>=0)
                {
                    //-- We are looking for specifically the word "Offset" and not words like "TipOffset"
                    if (contains_word(line,s_offset))
                    {
                        // cout << "number of links 2: "<<new_part_count<<"\n\n";
                        new_part_count++;

                        //-- Look for the string "X="
                        int index_X = newline.find(s_X);
                        //-- Look for the string "Y="
                        int index_Y = newline.find(s_Y);
                        //-- Look for the string "Z="
                        int index_Z = newline.find(s_Z);
                        //-- Look for commas that separate X, Y, and Z
                        int index_comma = newline.find(s_comma);
                        //-- Look for the closing parenthesis on this line
                        int indexClosingParenthesis = newline.find(s_closingParenthesis);

                        //-- Count the number of commas in each line
                        int comma_count = 0;

                        for(std::string::size_type pos=0; pos<line.size(); pos+=s_comma.size())
                        {
                            //-- Find the position of commas in the string
                            //-- There are 2 commas in "Offset=(X= .512,Y= .252, Z = -1.384)"
                            pos=newline.find(s_comma, pos);
                            if(pos==std::string::npos)
                                break;
                            comma_count++;

                            //-- We get the value for X
                            if (comma_count==1)
                            {
                                int strlength = s_X.length();
                                std::string s_xvalue = newline.substr(index_X+strlength,pos-(index_X+strlength));

                                //-- If the first character of s_xvalue is a "."
                                //-- Add "0" in the front
                                if (isDotPositiveDecimal(s_xvalue))
                                    changeDotPositiveDecimal (s_xvalue,"0");

                                if (isDotNegativeDecimal(s_xvalue))
                                    changeDotNegativeDecimal (s_xvalue,"0");

                                //std::cout <<"s_xvalue: "<< s_xvalue << endl;
                                d_xvalue = atof(s_xvalue.c_str());
                            }
                            //-- We get the value for Y
                            else if (comma_count==2)
                            {
                                int strlength = s_Y.length();
                                std::string s_yvalue = newline.substr(index_Y+strlength,pos-(index_Y+strlength));

                                if (isDotPositiveDecimal(s_yvalue))
                                    changeDotPositiveDecimal (s_yvalue,"0");

                                if (isDotNegativeDecimal(s_yvalue))
                                    changeDotNegativeDecimal (s_yvalue,"0");


                                //std::cout <<"s_yvalue: "<< s_yvalue << endl;
                                d_yvalue = atof(s_yvalue.c_str());
                            }
                        }
                        comma_count = 0;

                        //-- Look for the position of the closing parenthesis
                        //-- This used to find the Z value
                        if (indexClosingParenthesis>=0)
                        {
                            int strlength = s_Z.length();
                            std::string s_zvalue = newline.substr(index_Z+strlength,indexClosingParenthesis-(index_Z+strlength));

                            if (isDotPositiveDecimal(s_zvalue))
                                changeDotPositiveDecimal (s_zvalue,"0");

                            if (isDotNegativeDecimal(s_zvalue))
                                changeDotNegativeDecimal (s_zvalue,"0");

                            d_zvalue = atof(s_zvalue.c_str());
                        }

                        //-- At checkpoint #1 (see above), x, y, and z were assigned the value of 0, 0, 0
                        //-- Here update these values with numbers read from the .uc file
                        std::vector<double> tmpVector;

                        //cout << "d_xvalue: "<<d_xvalue<<" d_yvalue: "<<d_yvalue<<" d_zvalue: "<<d_zvalue<<endl;
                        tmpVector.push_back(d_xvalue);
                        tmpVector.push_back(d_yvalue);
                        tmpVector.push_back(d_zvalue);

                        std::map<std::string,std::vector<double> >  myMap = armlink->getOffsetMap();
                        std::map<std::string,std::vector<double> >::iterator it;

                        //-- Look for the current link (partName)
                        it=myMap.find(partName);
                        if (it != myMap.end())
                            //-- update the values of x, y, z
                            it->second = tmpVector;
                        //-- assign armLink->linkOffsetMap to myMap
                        armlink->setOffsetMap(myMap);
                    }
                }
            }
        }
    }
    //readMapOfVector(armlink->getOffsetMap());
    map<string, vector<double> > myMap = armlink->getOffsetMap();

    ArmLink *tmpArmlink;
    for(map<string, vector<double> >::iterator iter = myMap.begin(); iter != myMap.end(); ++iter )
    {
        tmpArmlink = new ArmLink();
        tmpArmlink->setLinkName(iter->first);
        tmpArmlink->setOffsetVector(iter->second[0],iter->second[1],iter->second[2]);
        this->addArmLinkToList(tmpArmlink);
    }


    //-- Read the vector we just built
    //displayUCLink();

    //readMapOfVector(this->getArmLink());
    delete armlink;
    //delete tmpArmlink;
    inputfile.close();
}

/*!
 \brief Read a <b>urdf</b> file and store its data in memory.

 This function consists of two other functions:
 <ul>
 <li>FileOperator::readURDFLink reads and stores information on each link.
 <li>FileOperator::readURDFJoint reads and stores information on each joint.
 </ul>
 The data that are stored are used later on to build the final <b>urdf</b> file.
 */
void FileOperator::readUrdfFile(std::string _input_file)
{
    //-- Main Node
    XMLNode root_node=XMLNode::openFileHelper(_input_file.c_str(),"robot");
    readUrdfLink(root_node);
    readUrdfJoint(root_node);
}

/**
 \brief Read a <b>urdf</b> file and store data for each joint.

 This function retrieves information for joints that are described in the <b>urdf</b> file with the following structure:

 \htmlonly
 <font color=9900FF> &lt;joint </font> <font color="red">name</font>="KR60Arm_joint_1" <font color="red">type</font>="revolute"<font color=9900FF>&gt;</font><BR>
 &nbsp;&nbsp;&nbsp;<font color=9900FF>&lt;parent</font>  <font color="red">link</font>="KR60Arm_link0"<font color=9900FF>/&gt;</font><BR>
 &nbsp;&nbsp;&nbsp;<font color=9900FF>&lt;child</font>  <font color="red">link</font>  ="KR60Arm_link1"<font color=9900FF>/&gt;</font><BR>
 &nbsp;&nbsp;&nbsp;<font color=9900FF>&lt;origin</font>  <font color="red">xyz</font>  ="0.11 0.02 -0.79" <font color="red">rpy</font>="3.14 -0.00 0.00"<font color=9900FF>/&gt;</font><BR>
 &nbsp;&nbsp;&nbsp;<font color=9900FF>&lt;axis</font>  <font color="red">xyz</font>  ="0.0 0.0 1" <font color=9900FF>/&gt;</font><BR>
 &nbsp;&nbsp;&nbsp;<font color=9900FF>&lt;limit</font>  <font color="red">effort</font>  ="600.00"
 <font color="red">lower</font>  ="-3.14"  <font color="red">upper</font> ="3.14" <font color="red">velocity</font>="1.0" <font color=9900FF>/&gt;</font><BR>
 <font color=9900FF>&lt;/joint&gt;</font>
 \endhtmlonly

 \param root_node The root node of the <b>urdf</b> file.
 */
void FileOperator::readUrdfJoint(XMLNode root_node)
{
    //-- Get the number of "joint" nodes in the URDF file
    int n_joint = root_node.nChildNode("joint");
    std::vector<URDF*> tmp_urdfjoint;
    tmp_urdfjoint.reserve(n_joint);

    for (int i=0; i<n_joint; i++)
    {
        URDF *urdf= new URDF();

        //****** <joint> node ******//
        XMLNode joint_node=root_node.getChildNode("joint",i);
        //-- attribute "name"
        std::string joint_name_attr = joint_node.getAttribute("name");
        //cout << "joint name: " << joint_name_attr << endl;

        //-- attribute "type"
        std::string joint_type_attr = joint_node.getAttribute("type");
        //cout << "joint type: " << joint_type_attr << endl;
        urdf->setJoint(joint_name_attr,joint_type_attr);

        //****** <parent> node ******//
        XMLNode joint_parent_node=joint_node.getChildNode("parent");
        //-- attribute "link"
        std::string  joint_parent_link_attr=joint_parent_node.getAttribute("link");
        //cout << "parent link: " << joint_parent_link_attr << endl;
        urdf->setJointParent(joint_parent_link_attr);

        //****** <child> node ******//
        XMLNode joint_child_node=joint_node.getChildNode("child");
        //-- attribute "link"
        std::string  joint_child_link_attr=joint_child_node.getAttribute("link");
        //cout << "child link: " << joint_child_link_attr << endl;
        urdf->setJointChild(joint_child_link_attr);

        //****** <origin> node ******//
        XMLNode joint_origin_node=joint_node.getChildNode("origin");
        //-- attribute "xyz"
        std::string  joint_origin_xyz_attr=joint_origin_node.getAttribute("xyz");
        //-- attribute "rpy"
        std::string  joint_origin_rpy_attr=joint_origin_node.getAttribute("rpy");
        urdf->setJointOrigin(joint_origin_xyz_attr,joint_origin_rpy_attr);

        if (joint_node.nChildNode("axis")==1)
        {
            //****** <axis> node ******//
            XMLNode joint_axis_node=joint_node.getChildNode("axis");
            //-- attribute "xyz"
            std::string  joint_axis_xyz_attr=joint_axis_node.getAttribute("xyz");
            urdf->setJointAxis(joint_axis_xyz_attr);
        }

        if (joint_node.nChildNode("limit")==1)
        {
            //****** <limit> node ******//
            XMLNode joint_limit_node=joint_node.getChildNode("limit");
            //-- attribute "effort"
            std::string  joint_limit_effort_attr=joint_limit_node.getAttribute("effort");
            //-- attribute "lower"
            std::string  joint_limit_lower_attr=joint_limit_node.getAttribute("lower");
            //-- attribute "upper"
            std::string  joint_limit_upper_attr=joint_limit_node.getAttribute("upper");
            //-- attribute "velocity"
            std::string  joint_limit_velocity_attr=joint_limit_node.getAttribute("velocity");
            urdf->setJointLimit(joint_limit_effort_attr,
                                joint_limit_lower_attr,
                                joint_limit_upper_attr,
                                joint_limit_velocity_attr);
        }
        //-- Add urdf1 to the vector
        tmp_urdfjoint.push_back(urdf);
    }
    //-- Set tmp_urdfjoint to the member vector of this class
    setUrdfJointList(tmp_urdfjoint);

    //delete(urdf1);
}

/*!
 \brief Read a <b>urdf</b> file and store data for each link.

 This function retrieves information for links that are described in the <b>URDF</b> file with the following structure:

 \htmlonly
 <font color=9900FF> &lt;link </font> <font color="red">name</font> ="KR60Arm_link0"<font color=9900FF>&gt;</font><BR>
 &nbsp;&nbsp;&nbsp;<font color=9900FF> &lt;visual&gt;</font><BR>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=9900FF> &lt;geometry&gt;</font><BR>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=9900FF> &lt;box</font> <font color="red">size</font>= "0.80 0.05 0.05"<font color=9900FF>/&gt;</font><BR>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=9900FF> &lt;/geometry&gt;</font><BR>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=9900FF> &lt;origin</font> <font color="red">xyz</font>="0.06 0.01 -0.40" <font color="red">rpy</font>="0.00 1.43 0.18"<font color=9900FF>/&gt;</font><BR>
 &nbsp;&nbsp;&nbsp;<font color=9900FF> &lt;visual&gt;</font><BR>
 <font color=9900FF> &lt;link&gt;</font><BR>
 \endhtmlonly

 \param _root_node The root node of the <b>URDF</b> file.
 */
void FileOperator::readUrdfLink(XMLNode _root_node)
{
    //-- Get the number of "link" nodes in the URDF file
    int n_link = _root_node.nChildNode("link");
    std::vector<URDF*> tmp_urdflink;
    tmp_urdflink.reserve(n_link);

    if (n_link>0)
        for (int i=0; i<n_link; i++)
        {
            URDF *urdf = new URDF();
            //****** <link> node ******//
            XMLNode link_node=_root_node.getChildNode("link",i);
            //-- attribute "name"
            std::string link_name_attr = link_node.getAttribute("name");
            //cout << "NAME: "<<link_name_attr<<endl;
            urdf->setLink_name(link_name_attr);

            //-- If a child node "visual" for the node "link" exists
            if (link_node.nChildNode("visual") == 1)
            {
                //****** <visual> node ******//
                XMLNode visual_node=link_node.getChildNode("visual");
                //****** <geometry> node ******//
                XMLNode geometry_node=visual_node.getChildNode("geometry");
                //****** <box> node ******//
                XMLNode box_node=geometry_node.getChildNode("box");
                //-- attribute "size"
                std::string box_attribute_size = box_node.getAttribute("size");
                urdf->setLinkBox(box_attribute_size);

                //****** <origin> node ******//
                XMLNode origin_node=visual_node.getChildNode("origin");
                //-- attribute "xyz"
                std::string origin_attr_xyz = origin_node.getAttribute("xyz");
                //-- attribute "rpy"
                std::string origin_attr_rpy = origin_node.getAttribute("rpy");
                urdf->setLinkOrigin(origin_attr_xyz,origin_attr_rpy);
            }
            //-- Add urdf1 to the vector
            tmp_urdflink.push_back(urdf);
            //delete(urdf);
        }
    //-- Set tmp_urdflink to the member vector of this class
    setUrdfLinkList(tmp_urdflink);

    // delete(urdf);
}

/*!
 \brief Read the elements of a vector that contains a vector of string
 \param myVector The vector to read
 */
void FileOperator::readVectorOfVector(std::vector<std::vector<std::string> > _vector)
{
    for (std::vector<std::vector<std::string> >::size_type u = 0; u < _vector.size(); u++)
        for (std::vector<std::string>::size_type v = 0; v < _vector[u].size(); v++)
            cout << _vector[u][v] << " ";
    cout << endl;
}

/*!
 \brief Remove duplicate values in a vector
 \param myVector The vector to read
 */
void FileOperator::removeDuplicates(vector<string>& _vector)
{
    sort(_vector.begin(), _vector.end());
    _vector.erase(unique(_vector.begin(), _vector.end()), _vector.end());
}

/*!
 *\brief Remove parentheses in a string.
 *
 *\param _string String that contains parentheses.
 *\return The string \a _string without parentheses.
 *
 *The different steps are:
 *<ul>
 *   <li>Find the position \a pos1 of the closing parenthesis ")".
 *   <ul>
 *       <li>Use \a pos1 and remove the closing parenthesis from \a s with the <b>string::erase</b> function.
 *   </ul>
 *   <li>Find the position \a pos2 of the opening parenthesis "(".
 *   <ul>
 *       <li> Keep the string that starts after \a pos2 with the <b>string::substr</b> function.
 *   </ul>
 *</ul>
 */
std::string FileOperator::removeParentheses(std::string _string)
{
    size_t pos1, pos2;
    std::string newLine;
    std::string::iterator it;

    pos2 =_string.find(")");
    it=_string.begin()+pos2;
    _string.erase(it);

    pos1 = _string.find("(");
    newLine=_string.substr(pos1+1);

    //cout << newLine << "\n";
    return newLine;
}

/*!
 *\brief Fill out the vector \a m_armjoint with instances of the class ArmJoint.
 *
 *\param _armjoint An instance of the class ArmJoint to push in the vector \a m_armjoint.
 */
void FileOperator::setArmJoint(ArmJoint *_armjoint)
{
    m_armjoint.push_back(_armjoint);
}

/*!
 *\brief Set the joint orientation \a _joint_angles to MatrixOperator::m_joint_angle.
 *
 *\param _joint_angles The joint angles to set to FileOperator::m_joint_angle.
 */
void FileOperator::setJointAngle(std::vector<Vector3d> _joint_angles)
{
    m_joint_angle=_joint_angles;
}

/*!
 *\brief Set the vector of joint positions \a _joint_position to FileOperator::m_link_position.
 *
 *\param _joint_position The vector of joint positions to set to FileOperator::m_joint_position.
 */
void FileOperator::setJointPosition(std::vector<Vector3d> _joint_position)
{
    m_joint_position=_joint_position;
}

/*!
 *\brief Set the link position \a _link_position to FileOperator::m_link_position.
 *
 *\param _link_position The link position to set to FileOperator::m_link_position.
 */
void FileOperator::setLinkPosition(std::vector<Vector3d> _link_position)
{
    m_link_position=_link_position;
}

/*!
 *\brief Set the vector member \a FileOperator::m_urdfjoint_list.
 *
 *\param _vector The vector to set to FileOperator::m_urdfjoint_list.
 */
void FileOperator::setUrdfJointList(std::vector<URDF*> _vector)
{
    m_input_urdfjoint_list=_vector;
}

/*!
 \brief Set the vector member \a FileOperator::m_urdflink_list.
 \param _vector The vector to set to FileOperator::m_urdflink_list.
 */
void FileOperator::setUrdfLinkList(std::vector<URDF*> _vector)
{
    m_input_urdflink_list=_vector;
}

/*!
 *\brief Split string \a s and store each element in a std::vector<std::string>.
 *
 *\param s The string that needs to be split.
 *\return A vector that contains all elements from the string \a s.
 *
 *Example: Read the string "word1 word2 word3" and output vector<word1,word2,word3>
 */
std::vector<std::string> FileOperator::splitString(std::string _string)
{
    istringstream iss(_string);
    std::vector<std::string> tokens;

    copy(istream_iterator<string>(iss),
         istream_iterator<string>(),
         back_inserter<std::vector<std::string> >(tokens));

    return tokens;
}

std::string FileOperator::stringify(double x)
{
    std::ostringstream o;
    if (!(o << x))
    {
        cout << "Bad Conversion" << endl;
        exit(0);
    }
    return o.str();
}

/*!
 \brief Remove blank spaces in a string.

 \param str A string that contains blank spaces.
 \return A new string with the blank spaces stripped out.
 */
std::string FileOperator::stripSpace(std::string _string)
{
    std::string newstring = _string;
    for (int i=0; i<newstring.length(); i++)
        if (newstring[i]==' ')
        {
            newstring.erase(i,1);
            i--;
        }
    return newstring;
}

/*!
 \brief Write the output <b>urdf</b> file.

 In order to write the output <b>urdf</b> file, the following steps are performed:
 <ul>
 <li>Get urdf link data: <i>urdflinklist</i>=FileOperator::getUrdfLinkList().
 <li>Get urdf joint data: <i>urdfjointlist</i>=FileOperator::getUrdfJointList().
 <li>Get .uc link data: <i>armlinklist</i>=FileOperator::getArmLink().
 <li>Get .uc link data: <i>armjointlist</i>=FileOperator::getArmJoint().
 </ul>

 <i>urdflinklist</i> and <i>urdfjointlist</i> consist of link and joint data, respectively, retrieved from the input urdf file (from the command line <i>-input oldurdf.xml</i>). These data are not altered in any way and are put back in the output urdf file.<br>
 <i>armlinklist</i> and <i>armjointlist</i> consist of link and joint data, respectively, retrieved from the .uc file (defined in the macro KR60ARM_UC).

 In <i>armlinklist</i>:
 <ul>
    <li>The position of each link has been updated with computed data (MatrixOperator::computeLinkPosition()).
</ul>
In <i>armjointlist</i>:
 <ul>
    <li>The position of each joint has been updated with computed data (MatrixOperator::computeJointPosition()).
    <li>The orientation of each joint has been updated with computed data (MatrixOperator::computeJointAngles()).
</ul>

<h2>Structure of a Link in the output urdf file</h2>
An example of how a link is structured in the ouput urdf file is displayed below:

\verbatim
1.  <link name="KR60Arm_link0">
2.      <visual>
3.          <geometry>
4.              <mesh filename="package://usarsim_inf/urdf/meshes/kr60_1.dae"/>
5.          </geometry>
6.          <material name="White"/>
7.          <origin xyz="0. 0. 0" rpy="3.14 0 0." />
8.      </visual>
9.      <collision>
10.         <geometry>
11.             <box size = "0.80 0.05 0.05"/>
12.         </geometry>
13.         <origin xyz="0.06 0.01 -0.40" rpy="0.00 1.43 0.18" />
14.     </collision>
15. </link>
\endverbatim

In the sample of the output urdf file displayed above:
<ul>
    <li>Line 1: The value for the attribute "name" is retrieved from <i>urdflinklist</i>.
    <li>Line 4: The value for the attribute "filename" is retrieved from <i>armlinklist</i>.
    <li>Line 6: The value for the attribute "name" is harcoded when the output file is written.
    <li>Line 7: The values for the attributes "xyz" and "rpy" are retrieved from <i>armlinklist</i>.
    <li>Line 11: The value for the attribute "size" is retrieved from <i>urdflinklist</i>.
    <li>Line 13: The values for the attributes "xyz" and "rpy" are retrieved from <i>urdflinklist</i>.
</ul>

<h2>Structure of a Joint in the output urdf file</h2>
An example of how a joint is structured in the ouput urdf file is displayed below:

\verbatim
1.  <joint name="KR60Arm_joint_4" type="revolute">
2.      <parent link="KR60Arm_link3"/>
3.      <child link="KR60Arm_link4"/>
4.      <origin xyz="0.592 0.192 0" rpy="2.36 1.57 2.36" />
5.      <axis xyz="0.0 0.0 1" />
6.      <limit effort="100.00" lower="-3.14" upper="3.14" velocity="1.0" />
7.  </joint>
\endverbatim

In the sample of the output urdf file displayed above:
<ul>
    <li>Line 1: The values for the attributes "name" and "type" are retrieved from <i>urdfjointlist</i>.
    <li>Lines 2-3: The values for the attribute "link" are retrieved from <i>urdfjointlist</i>.
    <li>Line 4: The values for the attributes "xyz" and "rpy" are retrieved from <i>armjointlist</i>.
    <li>Line 5: The value for the attribute "xyz" is retrieved from <i>armjointlist</i>.
    <li>Line 6: The values for the attributes "effort", "lower", "upper", and "velocity" are retrieved from <i>urdfjointlist</i>.
</ul>

 \param _filename The name of the output file.
 \return 0 If the output file \a _filename is successfully created and consists of data. 1 if \a _filename cannot be opened for writing.
 */
int FileOperator::writeUrdfFile(std::string _filename)
{
    std::ofstream fs(_filename.c_str());
    if(!fs)
    {
        std::cerr<<"Cannot open the output file."<<std::endl;
        return 1;
    }

    std::vector<URDF*> tmpurdf_link = getUrdfLinkList();
    std::vector<URDF*> tmpurdf_joint = getUrdfJointList();
    std::vector<ArmLink*> uc_link = getArmLink();
    std::vector<ArmJoint*> uc_joint = getArmJoint();


    Writer writer(fs);
    writer.openElt("robot").attr("name", "KR60");
    writer.openElt("material").attr("name", "White");
    writer.openElt("color").attr("rgba", "1.0 1.0 1.0 1.0").closeElt();
    writer.closeElt();
    writer.openElt("material").attr("name", "Black");
    writer.openElt("color").attr("rgba", "0.1 0.1 0.1 1.0").closeElt();
    writer.closeElt();

    //-- Write Link information
    for (vector<URDF*>::size_type i = 0; i < tmpurdf_link.size(); i++)
    {
        std::string urdf_link_name=tmpurdf_link[i]->getLink_name();
        if (i==0)
        {
            writer.openElt("link").attr("name", urdf_link_name);
            writer.closeElt();//-- Closing <link>
        }
        else
        {
            writer.openElt("link").attr("name", urdf_link_name);
            writer.openElt("visual");
            writer.openElt("geometry");
            for (vector<ArmLink*>::size_type j = 0; j < uc_link.size(); j++)
            {
                std::string uc_link_name=uc_link[j]->getLinkName();

                if (urdf_link_name.compare(uc_link_name)==0)
                {
                    std::string uc_collada_path=uc_link[j]->getColladaPath();
                    writer.openElt("mesh").attr("filename", uc_collada_path).closeElt();
                }
            }
            writer.closeElt();//-- Closing <geometry>
            writer.openElt("material").attr("name", "White").closeElt();
            for (vector<ArmLink*>::size_type j = 0; j < uc_link.size(); j++)
            {
                std::string uc_link_name=uc_link[j]->getLinkName();

                if (urdf_link_name.compare(uc_link_name)==0)
                {

                    vector<double> v_link_offset=uc_link[j]->getOffsetVector();
                    std::string x = stringify(v_link_offset[0]);
                    std::string y = stringify(v_link_offset[1]);
                    std::string z = stringify(v_link_offset[2]);

                    std::string space(" ");
                    std::string xyz = x + space + y + space + z;

                    vector<double> v_link_rpy=uc_link[j]->getRPYVector();
                    std::string roll = stringify(v_link_rpy[0]);
                    std::string pitch = stringify(v_link_rpy[1]);
                    std::string yaw = stringify(v_link_rpy[2]);

                    std::string rpy = roll + space + pitch + space + yaw;

                    writer.openElt("origin").attr("xyz", xyz).attr("rpy", rpy).closeElt();
                }
            }

            writer.closeElt();//-- Closing <visual>

            std::string urdf_link_box_size=tmpurdf_link[i]->getLinkBox_size();
            std::string urdf_link_origin_xyz=tmpurdf_link[i]->getLinkOrigin_xyz();
            std::string urdf_link_origin_rpy=tmpurdf_link[i]->getLinkOrigin_rpy();

            writer.openElt("collision");
            writer.openElt("geometry");
            writer.openElt("box").attr("size", urdf_link_box_size).closeElt();;
            writer.closeElt();
            writer.openElt("origin").attr("xyz", urdf_link_origin_xyz).attr("rpy", urdf_link_origin_rpy).closeElt();;
            writer.closeElt();

            writer.closeElt();//-- Closing <link>
        }
    }

    //-- Write Joint information
    for (vector<URDF*>::size_type k = 0; k < tmpurdf_joint.size(); k++)
    {
        std::string urdf_joint_name=tmpurdf_joint[k]->getJoint_name();
        std::string urdf_joint_type=tmpurdf_joint[k]->getJoint_type();
        std::string urdf_joint_parent=tmpurdf_joint[k]->getJointParent_link();
        std::string urdf_joint_child=tmpurdf_joint[k]->getJointChild_link();
        std::string urdf_joint_axis=tmpurdf_joint[k]->getJointAxis_xyz();
        std::string urdf_joint_effort=tmpurdf_joint[k]->getJointLimit_effort();
        std::string urdf_joint_lower=tmpurdf_joint[k]->getJointLimit_lower();
        std::string urdf_joint_upper=tmpurdf_joint[k]->getJointLimit_upper();
        std::string urdf_joint_velocity=tmpurdf_joint[k]->getJointLimit_velocity();

        writer.openElt("joint").attr("name", urdf_joint_name).attr("type", urdf_joint_type);
        writer.openElt("parent").attr("link", urdf_joint_parent).closeElt();
        writer.openElt("child").attr("link", urdf_joint_child).closeElt();

        for (vector<ArmJoint*>::size_type l = 0; l < uc_joint.size(); l++)
        {
            std::string uc_joint_name=uc_joint[l]->getJointName();

            if (urdf_joint_name.compare(uc_joint_name)==0)
            {
                vector<double> v_joint_xyz=uc_joint[l]->getJointOffsetVector();
                std::string x = stringify(v_joint_xyz[0]);
                std::string y = stringify(v_joint_xyz[1]);
                std::string z = stringify(v_joint_xyz[2]);

                vector<double> v_joint_rpy=uc_joint[l]->getJointRPYVector();
                std::string roll = stringify(v_joint_rpy[0]);
                std::string pitch = stringify(v_joint_rpy[1]);
                std::string yaw = stringify(v_joint_rpy[2]);

                std::string space(" ");
                std::string xyz = x + space + y + space + z;
                std::string rpy = roll + space + pitch + space + yaw;

                writer.openElt("origin").attr("xyz", xyz).attr("rpy", rpy).closeElt();
            }
        }


        if (!urdf_joint_axis.empty())
            writer.openElt("axis").attr("xyz", urdf_joint_axis).closeElt();

        if (!urdf_joint_effort.empty())
            if (!urdf_joint_lower.empty())
                if (!urdf_joint_upper.empty())
                    if (!urdf_joint_velocity.empty())
                    {
                        writer.openElt("limit")
                        .attr("effort", urdf_joint_effort)
                        .attr("lower", urdf_joint_lower)
                        .attr("upper", urdf_joint_upper)
                        .attr("velocity", urdf_joint_velocity)
                        .closeElt();
                    }
        writer.closeElt();
    }

    writer.closeAll();
    std::cout << std::endl;
    fs.close();
    return 0;
}
